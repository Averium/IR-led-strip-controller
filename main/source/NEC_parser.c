#include "NEC_parser.h"


bool parse_nec_frame(
    const rmt_symbol_word_t *symbols,
    const size_t num_symbols,
    uint32_t *out_address,
    uint32_t *out_command
) {
    /* ===[ This function is mostly generated by ChatGPT ]======================================= */
    /* Decodes raw IR data frame at <symbols> to a NEC frame into <out_address> and <out_command> */

    // NEC repeat frames
    if (num_symbols >= 2 &&
        within(symbols[0].duration0, NEC_HEADER_HIGH_US, NEC_TOLERANCE_PCT) &&
        within(symbols[0].duration1, NEC_REPEAT_SPACE_US, NEC_TOLERANCE_PCT) &&
        within(symbols[1].duration0, NEC_BIT_MARK_US, NEC_TOLERANCE_PCT)) {
        
        if (out_address) *out_address = 0x00;
        if (out_command) *out_command = 0xFF;

        return true;
    }

    // Not enough symbols
    if (num_symbols < 34) { return false; }

    // RMT stores durations in ticks (1 tick = 1 us at 1MHz resolution)
    const rmt_symbol_word_t *sym = &symbols[0];

    // Check header
    if (!within(sym->duration0, NEC_HEADER_HIGH_US, NEC_TOLERANCE_PCT) ||
        !within(sym->duration1, NEC_HEADER_LOW_US, NEC_TOLERANCE_PCT)) {
        return false;
    }

    uint32_t data = 0;

    // Bits start after header: symbol[1..32]
    for (int i = 1; i <= 32; i++) {
        sym = &symbols[i];

        // Each bit should start with ~560us high
        if (!within(sym->duration0, NEC_BIT_MARK_US, NEC_TOLERANCE_PCT)) {
            return false;
        }

        if (within(sym->duration1, NEC_ONE_SPACE_US, NEC_TOLERANCE_PCT)) {
            data = (data << 1) | 1;
        } else if (within(sym->duration1, NEC_ZERO_SPACE_US, NEC_TOLERANCE_PCT)) {
            data = (data << 1) | 0;
        } else {
            return false; // invalid symbol
        }
    }

    uint8_t addr     = (data >> 24) & 0xFF;
    uint8_t addr_inv = (data >> 16) & 0xFF;
    uint8_t cmd      = (data >> 8)  & 0xFF;
    uint8_t cmd_inv  = (data >> 0)  & 0xFF;

    // validate inverted bytes
    if ((addr ^ addr_inv) != 0xFF || (cmd ^ cmd_inv) != 0xFF) {
        return false;
    }

    if (out_address) *out_address = addr;
    if (out_command) *out_command = cmd;

    return true;
}
